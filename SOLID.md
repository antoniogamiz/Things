## SOLID Principles [article](https://blog.bitsrc.io/solid-principles-every-developer-should-know-b3bfa96bb688)

* S: Single Responsibility Principle
* O: Open-Closed Principle
* L: Liskov Substitution Principle
* I: Interface Segregation Principle
* D: Depenedncy Inversion Principle

* S: A class should be responsible for only one thing. If a class has more than one responsibility, it becomes coupled. A change to one responsibility results to modification of the other responsibility.
* O: Software entities(Classes, modules, functions) should be open for extension, not modification.
* L: A sub-class must be substitutable for its super-class: The aim of this principle is to ascertain that a sub-class can assume the place of its super-class without errors. If the code finds itself checking the type of class then, it must have violated this principle.

Requirements postulated by Steve Fenton in order to follow the LSP principle:

* If the super-class (Animal) has a method that accepts a super-class type (Animal) parameter. Its sub-class(Pigeon) should accept as argument a super-class type (Animal type) or sub-class type(Pigeon type).
* If the super-class returns a super-class type (Animal). Its sub-class should return a super-class type (Animal type) or sub-class type(Pigeon).

* I: Make fine grained interfaces that are client specific. Clients should not be forced to depend upon interfaces that they do not use. This principle deals with the disadvantages of implementing big interfaces.

* D: Dependency should be on abstractions not concretions
  * A. High-level modules should not depend upon low-level modules. Both should depend upon abstractions.
  * B. Abstractions should not depend on details. Details should depend upon abstractions.
